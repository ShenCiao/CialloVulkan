#version 460
#extension GL_EXT_debug_printf : enable

layout(local_size_x = 1024) in;


struct Vertex {
    vec2 pos;
    vec2 _pad0;
    vec3 color;
    float _pad1;
};

layout(std430, binding = 0) buffer Input{
    Vertex[] inVertices;
};

layout(std430, binding = 1) buffer Output{
    Vertex[] outVertices;
};

layout(std430, binding = 2) buffer DrawIndirectCommand{
    uint vertexCount;
    uint instanceCount;
    uint firstVertex;
    uint firstInstance;
} draw;

shared float[gl_WorkGroupSize.x * 2] segmentLengths;
shared uint n_totDots;

void main(){
    uint id = gl_LocalInvocationID.x;
    vec2 p0 = inVertices[id].pos;
    vec2 p1 = id == 0 ? p0:inVertices[id - 1].pos;
    // length of each segment
    float curLength = distance(p0, p1);
    segmentLengths[id] = curLength;

    barrier();
	memoryBarrierShared();

    // Prefix sum on segment length
    const uint n_steps = uint(log2(gl_WorkGroupSize.x)) + 1;

    for(uint s = 0; s < n_steps; s++){
        uint mask = (1 << s) - 1;
		uint rd_id = ((id >> s) << (s + 1)) + mask;
		uint wr_id = rd_id + 1 + (id & mask);
		
		segmentLengths[wr_id] += segmentLengths[rd_id];
		
		barrier();
		memoryBarrierShared();
    }
    // Prefix sum done! For now segmentLengths is the distance from the starting point of polyline

    // if(id < inVertices.length()){
    //     debugPrintfEXT("pos: %.2f %.2f", inVertices[id].pos[0], inVertices[id].pos[1]);
    //     debugPrintfEXT("color: %.2f %.2f %.2f", inVertices[id].color[0], inVertices[id].color[1], inVertices[id].color[2]);
    // }

    float dotDistance = 0.02;
    
    // Only invocation id within [0, inVertices.length()) supposed to be dealed with
    if (id != 0 && id < inVertices.length()) {
        float tDistance = dotDistance - mod(segmentLengths[id - 1], dotDistance);
        uint idOut = uint( segmentLengths[id - 1]/dotDistance );

        while (tDistance + segmentLengths[id - 1] < segmentLengths[id]){
            idOut += 1;
            float t = tDistance/curLength;
            // interpolate everything with t value
            outVertices[idOut].pos = mix(inVertices[id-1].pos, inVertices[id].pos, t);
            outVertices[idOut].color = mix(inVertices[id-1].color, inVertices[id].color, t);

            tDistance += dotDistance;
        }

        if (id == inVertices.length() - 1) // endpoint of poyline
        {
            // pad one dot at the end of stroke
            
            draw.vertexCount = idOut+2; 
            debugPrintfEXT("idOut: %d", draw.vertexCount);
            outVertices[idOut+1].pos = outVertices[idOut].pos + inVertices[id].pos - inVertices[id-1].pos;
            outVertices[idOut+1].color = outVertices[idOut].color;
        }
    }
    else if(id == 0){
        outVertices[0].pos = inVertices[0].pos;
        outVertices[0].color = inVertices[0].color;

        draw.instanceCount = 1;
        draw.firstVertex = 0;
        draw.firstInstance = 0;
    }
}